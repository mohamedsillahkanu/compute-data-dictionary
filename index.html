<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compute New Variables Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { margin: 0; padding: 20px; background-color: #ffffff; font-family: 'Oswald', Arial, sans-serif; color: #000000; font-weight: 500; }
        .page-container { width: 100%; max-width: 1400px; margin: 0 auto; }
        .page-header { background-color: #004080; color: #ffffff; padding: 25px 30px; text-align: center; margin-bottom: 15px; border-radius: 8px 8px 0 0; }
        .logo-row { display: flex; justify-content: center; align-items: center; gap: 30px; margin-bottom: 15px; }
        .logo-box { background: #ffffff; border-radius: 8px; padding: 10px; display: flex; align-items: center; justify-content: center; }
        .logo-box img { width: 100px; height: auto; border-radius: 6px; }
        .page-header h3 { margin: 12px 0 5px; font-size: 14px; font-weight: 700; letter-spacing: 1px; color: #ffffff; }
        .page-header .tagline { margin: 0; font-size: 10px; font-weight: 500; color: #ffffff; }
        .page-header h1 { margin: 20px 0 10px; font-size: 24px; font-weight: 700; color: #ffffff; letter-spacing: 1px; }
        .page-header .subtitle { font-size: 14px; color: #ffffff; font-weight: 500; }
        .content-card { border: 4px double #004080; border-radius: 12px; padding: 12px; background-color: #ffffff; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); margin-bottom: 15px; }
        .content-inner { padding: 25px; }
        .upload-section { background: #f8f9fa; padding: 2rem; border-radius: 8px; border: 2px dashed #004080; text-align: center; margin: 1rem 0; transition: all 0.3s ease; }
        .upload-section:hover { border-color: #0056b3; background: #e7f3ff; }
        .upload-section h3 { color: #004080; margin-bottom: 1rem; font-size: 18px; font-weight: 700; }
        .upload-section p { color: #000000; font-weight: 500; font-size: 14px; }
        .file-input-wrapper { position: relative; display: inline-block; cursor: pointer; background: #004080; color: white; padding: 14px 24px; border-radius: 6px; border: 2px solid #004080; font-size: 14px; font-weight: 700; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.5px; font-family: 'Oswald', Arial, sans-serif; margin-top: 1rem; }
        .file-input-wrapper:hover { background: #0056b3; border-color: #0056b3; }
        .file-input-wrapper input[type="file"] { position: absolute; left: -9999px; }
        .file-status { margin-top: 15px; font-weight: 700; }
        .file-status.loaded { color: #28a745; }
        .file-status.error { color: #dc3545; }
        .section-header { background-color: #004080; color: #ffffff; padding: 15px 20px; margin-bottom: 20px; border-radius: 6px; display: flex; align-items: center; gap: 15px; }
        .section-icon { background: #ffffff; color: #004080; width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 700; flex-shrink: 0; }
        .section-title { font-size: 18px; font-weight: 700; letter-spacing: 0.5px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin: 1.5rem 0; }
        .stats-card { background: #f8f9fa; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); text-align: center; border: 2px solid #004080; transition: all 0.2s; }
        .stats-card:hover { transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0, 64, 128, 0.2); }
        .stats-card h4 { color: #666; font-size: 11px; margin-bottom: 0.5rem; text-transform: uppercase; }
        .stats-card .metric-value { font-size: 1.6rem; color: #004080; margin-bottom: 0.25rem; font-weight: 700; }
        .stats-card .metric-value.success { color: #28a745; }
        .stats-card .metric-value.warning { color: #ffc107; }
        .stats-card .metric-value.danger { color: #dc3545; }
        .stats-card p { color: #666; font-size: 11px; }
        .btn { padding: 14px 24px; border: 2px solid #004080; border-radius: 6px; font-size: 14px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px; font-family: 'Oswald', Arial, sans-serif; transition: all 0.2s; margin: 5px; }
        .btn-primary { background: #004080; color: #ffffff; }
        .btn-primary:hover { background: #0056b3; border-color: #0056b3; }
        .btn-secondary { background: #ffffff; color: #004080; }
        .btn-secondary:hover { background: #004080; color: #ffffff; }
        .btn-gold { background: #ffc107; color: #000000; border-color: #ffc107; }
        .btn-gold:hover { background: #e0a800; border-color: #e0a800; }
        .btn-success { background: #28a745; color: #ffffff; border-color: #28a745; }
        .btn-success:hover { background: #218838; border-color: #218838; }
        .btn:disabled { background: #6c757d; border-color: #6c757d; color: #ffffff; opacity: 0.6; cursor: not-allowed; }
        .alert { padding: 1rem; border-radius: 6px; margin: 1rem 0; font-weight: 500; }
        .alert-success { background: #d4edda; border: 2px solid #28a745; color: #155724; }
        .alert-warning { background: #fff3cd; border: 2px solid #ffc107; color: #856404; }
        .alert-error { background: #f8d7da; border: 2px solid #dc3545; color: #721c24; }
        .alert-info { background: #e7f3ff; border: 2px solid #004080; color: #004080; }
        .info-message { background: #e7f3ff; color: #004080; padding: 1rem; border-radius: 6px; border: 2px solid #004080; margin: 1rem 0; font-weight: 500; }
        .hidden { display: none !important; }
        .config-card { background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 2px solid #004080; margin: 1rem 0; }
        .config-card h4 { color: #004080; margin-bottom: 1rem; font-size: 16px; font-weight: 700; }
        .compute-list { max-height: 500px; overflow-y: auto; border: 2px solid #004080; border-radius: 6px; background: #ffffff; }
        .compute-item { display: grid; grid-template-columns: 1fr 120px 2fr 120px; gap: 1rem; padding: 1rem; border-bottom: 1px solid #ddd; align-items: center; }
        .compute-item:last-child { border-bottom: none; }
        .compute-item:hover { background: #f8f9fa; }
        .compute-item.valid { background: #d4edda; }
        .compute-item.invalid { background: #f8d7da; }
        .var-name { font-family: 'Courier New', monospace; background: #f8f9fa; padding: 0.5rem 1rem; border-radius: 4px; border: 1px solid #004080; color: #004080; font-weight: 500; word-break: break-all; }
        .var-name.new { background: #d4edda; border-color: #28a745; color: #155724; }
        .operation-badge { padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 11px; font-weight: 700; text-transform: uppercase; text-align: center; }
        .operation-badge.addition { background: #28a745; color: white; }
        .operation-badge.subtraction { background: #dc3545; color: white; }
        .operation-badge.multiplication { background: #6f42c1; color: white; }
        .operation-badge.division { background: #fd7e14; color: white; }
        .operation-badge.average { background: #17a2b8; color: white; }
        .operation-badge.maximum { background: #20c997; color: white; }
        .operation-badge.minimum { background: #6c757d; color: white; }
        .components-list { font-family: 'Courier New', monospace; font-size: 12px; color: #333; word-break: break-all; }
        .components-list .missing { color: #dc3545; text-decoration: line-through; }
        .components-list .found { color: #28a745; }
        .components-list .computed { color: #6f42c1; font-style: italic; }
        .status-badge { padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 11px; font-weight: 700; text-transform: uppercase; }
        .status-badge.valid { background: #28a745; color: white; }
        .status-badge.invalid { background: #dc3545; color: white; }
        .table-container { max-height: 400px; overflow: auto; border: 2px solid #004080; border-radius: 6px; }
        .results-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .results-table th { background: #004080; color: #ffffff; padding: 0.75rem; text-align: left; font-weight: 700; position: sticky; top: 0; }
        .results-table th.new-col { background: #28a745; }
        .results-table td { padding: 0.5rem 0.75rem; border-bottom: 1px solid #ddd; }
        .results-table td.new-col { background: #d4edda; font-weight: 600; }
        .results-table tr:nth-child(even) { background: #f8f9fa; }
        .results-table tr:hover { background: #e7f3ff; }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin: 1.5rem 0; }
        .feature-card { background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 2px solid #004080; }
        .feature-card h4 { color: #004080; margin-bottom: 1rem; font-size: 16px; font-weight: 700; text-transform: uppercase; }
        .feature-card ul, .feature-card ol { color: #000000; line-height: 1.8; padding-left: 1.5rem; }
        .feature-card li { margin-bottom: 0.5rem; font-weight: 500; font-size: 14px; }
        .feature-card strong { color: #004080; }
        .page-footer { background-color: #004080; color: #ffffff; padding: 20px 30px; text-align: center; font-size: 13px; line-height: 1.7; font-weight: 500; border-radius: 0 0 8px 8px; }
        .page-footer p { margin: 6px 0 0; font-size: 12px; color: #ffffff; }
        .upload-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .dict-format { background: #fff3cd; border: 2px solid #ffc107; border-radius: 6px; padding: 1rem; margin: 1rem 0; }
        .dict-format h5 { color: #856404; margin-bottom: 0.5rem; }
        .dict-format code { background: #ffffff; padding: 0.5rem; border-radius: 4px; display: block; margin-top: 0.5rem; font-size: 12px; }
        .column-tags { display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 1rem 0; max-height: 150px; overflow-y: auto; padding: 0.5rem; background: #f8f9fa; border-radius: 6px; }
        .column-tag { background: #004080; color: white; padding: 0.3rem 0.8rem; border-radius: 20px; font-size: 12px; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f8f9fa; border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: #004080; border-radius: 4px; }
        @media (max-width: 768px) {
            body { padding: 10px; }
            .content-inner { padding: 15px; }
            .page-header h1 { font-size: 20px; }
            .upload-grid { grid-template-columns: 1fr; }
            .compute-item { grid-template-columns: 1fr; gap: 0.5rem; }
            .stats-grid { grid-template-columns: 1fr 1fr; }
            .feature-grid { grid-template-columns: 1fr; }
            .btn { padding: 12px 20px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <div class="page-header">
            <div class="logo-row">
                <div class="logo-box">
                    <img src="https://github.com/mohamedsillahkanu/gdp-dashboard-2/raw/6c7463b0d5c3be150aafae695a4bcbbd8aeb1499/ICF-SL.jpg" alt="ICF-SL Logo">
                </div>
            </div>
            <h3>Informatics Consultancy Firm-Sierra Leone<br>(ICF-SL)</h3>
            <p class="tagline"><em>Driving Data-Driven Solutions for Health and Development</em></p>
            <h1>COMPUTE NEW VARIABLES TOOL</h1>
            <p class="subtitle">Create New Calculated Variables Using a Configuration File</p>
        </div>

        <div class="content-card">
            <div class="content-inner">
                <div id="alertContainer"></div>

                <!-- Upload Section -->
                <div id="uploadSection">
                    <div class="section-header">
                        <span class="section-icon">1</span>
                        <span class="section-title">UPLOAD FILES</span>
                    </div>

                    <div class="upload-grid">
                        <div class="upload-section" id="dataUploadSection">
                            <h3>STEP 1: DATA FILE</h3>
                            <p>Upload your main data file (CSV or Excel)</p>
                            <label class="file-input-wrapper">
                                Choose Data File
                                <input type="file" id="dataFileInput" accept=".csv,.xlsx,.xls">
                            </label>
                            <div id="dataFileStatus" class="file-status"></div>
                        </div>

                        <div class="upload-section" id="configUploadSection">
                            <h3>STEP 2: COMPUTATION CONFIG</h3>
                            <p>Upload computation rules file (CSV or Excel)</p>
                            <label class="file-input-wrapper">
                                Choose Config File
                                <input type="file" id="configFileInput" accept=".csv,.xlsx,.xls">
                            </label>
                            <div id="configFileStatus" class="file-status"></div>
                        </div>
                    </div>

                    <div class="dict-format">
                        <h5>Configuration File Format</h5>
                        <p>Your config file should have three columns: <strong>new_variable</strong>, <strong>operation</strong>, and <strong>components</strong> (comma-separated column names).</p>
                        <code>new_variable | operation | components<br>total_cases | addition | confirmed_cases, suspected_cases<br>net_cases | subtraction | total_cases, deaths<br>avg_value | average | value1, value2, value3<br>case_rate | division | cases, population</code>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="downloadTemplate()" style="padding: 10px 20px; font-size: 12px;">Download Sample Template</button>
                        </div>
                    </div>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>Supported Operations</h4>
                            <ul>
                                <li><strong>addition:</strong> Sum all component columns (NA treated as 0)</li>
                                <li><strong>subtraction:</strong> First minus second (NA treated as 0)</li>
                                <li><strong>multiplication:</strong> Multiply all columns (NA treated as 0)</li>
                                <li><strong>division:</strong> First divided by second</li>
                                <li><strong>average:</strong> Mean of non-NA values</li>
                                <li><strong>maximum:</strong> Maximum of non-NA values</li>
                                <li><strong>minimum:</strong> Minimum of non-NA values</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>NA Handling Rules</h4>
                            <ol>
                                <li><strong>NA + 2 = 2</strong> (NA treated as 0)</li>
                                <li><strong>2 - NA = 2</strong> (NA treated as 0)</li>
                                <li><strong>NA × 2 = 0</strong> (NA treated as 0)</li>
                                <li><strong>2 ÷ NA = blank</strong> (division by NA)</li>
                                <li><strong>Column Order:</strong> New vars placed after components</li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- Configuration Section -->
                <div id="configSection" class="hidden">
                    <div class="section-header">
                        <span class="section-icon">2</span>
                        <span class="section-title">COMPUTATION CONFIGURATION</span>
                    </div>

                    <div class="stats-grid" id="configStats"></div>

                    <div class="config-card">
                        <h4>Available Columns in Data File</h4>
                        <div class="column-tags" id="columnTags"></div>
                    </div>

                    <div class="config-card">
                        <h4>Computation Rules</h4>
                        <div class="info-message">
                            <strong>Green:</strong> Original column found | 
                            <strong style="color:#6f42c1;">Purple (⟵):</strong> Uses previously computed variable |
                            <strong style="color:#dc3545;">Red:</strong> Missing column |
                            <strong>Order matters:</strong> Rules are processed top-to-bottom |
                            <strong>NA = 0:</strong> Missing values treated as zero in calculations
                        </div>
                        <div class="compute-list" id="computeList"></div>
                    </div>

                    <div style="text-align: center; margin-top: 1.5rem;">
                        <button class="btn btn-gold" id="computeBtn" onclick="computeVariables()">Compute Variables</button>
                        <button class="btn btn-secondary" onclick="resetAll()">Start Over</button>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="resultsSection" class="hidden">
                    <div class="section-header">
                        <span class="section-icon">3</span>
                        <span class="section-title">COMPUTED DATA</span>
                    </div>

                    <div class="stats-grid" id="resultStats"></div>

                    <div class="config-card">
                        <h4>Computation Summary</h4>
                        <div id="computeSummary"></div>
                    </div>

                    <div class="config-card">
                        <h4>Data Preview (First 100 Rows) - New columns placed after their components</h4>
                        <div class="table-container">
                            <table class="results-table" id="previewTable">
                                <thead id="previewHead"></thead>
                                <tbody id="previewBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 2rem 0;">
                        <button class="btn btn-success" onclick="downloadExcel()">Download Excel</button>
                        <button class="btn btn-primary" onclick="downloadCSV()">Download CSV</button>
                        <button class="btn btn-secondary" onclick="backToConfig()">Back to Config</button>
                        <button class="btn btn-secondary" onclick="resetAll()">Start Over</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="page-footer">
            <p style="margin: 0; font-weight: 700;">National Malaria Control Programme</p>
            <p>Ministry of Health and Sanitation, Sierra Leone</p>
            <p style="font-size: 11px;">Medical Stores Compound, Freetown, Sierra Leone</p>
            <p style="font-size: 10px;">© 2025 Informatics Consultancy Firm-Sierra Leone (ICF-SL)</p>
        </div>
    </div>

    <script>
        let dataFile = null;
        let configFile = null;
        let originalData = [];
        let originalColumns = [];
        let originalColumnsLower = {}; // Map lowercase -> original name
        let computations = [];
        let computedData = [];
        let newColumns = [];
        let orderedColumns = []; // For smart column ordering

        // Operation display names mapping
        const operationDisplayNames = {
            'addition': 'Addition',
            'subtraction': 'Subtraction',
            'multiplication': 'Multiplication',
            'division': 'Division',
            'average': 'Average',
            'maximum': 'Maximum',
            'minimum': 'Minimum'
        };

        // Normalize operation names
        function normalizeOperation(op) {
            const normalized = op.toLowerCase().trim();
            if (['add', 'addition', 'sum'].includes(normalized)) return 'addition';
            if (['subtract', 'subtraction', 'minus'].includes(normalized)) return 'subtraction';
            if (['multiply', 'multiplication', 'product'].includes(normalized)) return 'multiplication';
            if (['divide', 'division'].includes(normalized)) return 'division';
            if (['average', 'avg', 'mean'].includes(normalized)) return 'average';
            if (['max', 'maximum'].includes(normalized)) return 'maximum';
            if (['min', 'minimum'].includes(normalized)) return 'minimum';
            return normalized;
        }

        /**
         * NORMALIZE COLUMN NAME
         * Trim whitespace, handle common issues
         */
        function normalizeColName(name) {
            if (!name) return '';
            return String(name).trim().replace(/\s+/g, ' ');
        }

        /**
         * FIND MATCHING COLUMN (case-insensitive with fallback)
         * Returns the actual column name that matches
         */
        function findMatchingColumn(searchName, availableColumns) {
            const normalized = normalizeColName(searchName);
            
            // First try exact match
            if (availableColumns.includes(normalized)) {
                return normalized;
            }
            
            // Try case-insensitive match
            const lowerSearch = normalized.toLowerCase();
            for (let col of availableColumns) {
                if (col.toLowerCase() === lowerSearch) {
                    return col;
                }
            }
            
            // No match found
            return null;
        }

        /**
         * ROBUST NUMERIC CONVERSION
         * Handles: numbers, strings with numbers, NA, N/A, null, undefined, empty strings, whitespace
         * Returns: { value: number|null, isNA: boolean }
         */
        function toNumeric(val) {
            // Handle null, undefined
            if (val === null || val === undefined) {
                return { value: null, isNA: true };
            }
            
            // If already a number
            if (typeof val === 'number') {
                if (isNaN(val)) {
                    return { value: null, isNA: true };
                }
                return { value: val, isNA: false };
            }
            
            // Convert to string and trim
            let str = String(val).trim();
            
            // Check for empty string
            if (str === '') {
                return { value: null, isNA: true };
            }
            
            // Check for NA variants (case-insensitive)
            const naPatterns = ['na', 'n/a', 'nan', 'null', 'nil', '-', '.', '#n/a', '#value!', '#ref!', '#div/0!', 'missing', 'undefined'];
            if (naPatterns.includes(str.toLowerCase())) {
                return { value: null, isNA: true };
            }
            
            // Remove commas and spaces from numbers (e.g., "1,234" -> "1234")
            str = str.replace(/,/g, '').replace(/\s/g, '');
            
            // Try to parse as number
            const num = parseFloat(str);
            
            if (isNaN(num)) {
                return { value: null, isNA: true };
            }
            
            return { value: num, isNA: false };
        }

        /**
         * PRE-PROCESS DATA: Convert all numeric columns to actual numbers
         * Also normalizes column names (trim whitespace)
         * This runs ONCE after data is loaded
         */
        function preprocessData(data) {
            if (data.length === 0) return [];
            
            // First, normalize column names in the data
            const oldKeys = Object.keys(data[0]);
            const keyMapping = {}; // old -> new (normalized)
            
            oldKeys.forEach(key => {
                keyMapping[key] = normalizeColName(key);
            });
            
            return data.map(row => {
                const newRow = {};
                Object.keys(row).forEach(oldKey => {
                    const newKey = keyMapping[oldKey];
                    const result = toNumeric(row[oldKey]);
                    
                    // Keep original value for non-numeric columns, convert numeric ones
                    if (result.isNA) {
                        newRow[newKey] = null; // Standardize all NA to null
                    } else if (result.value !== null) {
                        newRow[newKey] = result.value;
                    } else {
                        // Keep as string if it's truly non-numeric text
                        newRow[newKey] = row[oldKey];
                    }
                });
                return newRow;
            });
        }

        document.getElementById('dataFileInput').addEventListener('change', function(e) { handleDataFile(e.target.files[0]); });
        document.getElementById('configFileInput').addEventListener('change', function(e) { handleConfigFile(e.target.files[0]); });

        function showAlert(message, type) {
            const container = document.getElementById('alertContainer');
            const div = document.createElement('div');
            div.className = 'alert alert-' + type;
            div.textContent = message;
            container.innerHTML = '';
            container.appendChild(div);
            setTimeout(function() { if (div.parentNode) div.parentNode.removeChild(div); }, 5000);
        }

        function parseFile(file, callback) {
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (ext === 'csv') {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) { callback(results.data); },
                    error: function(err) { showAlert('Error reading CSV: ' + err.message, 'error'); }
                });
            } else if (ext === 'xlsx' || ext === 'xls') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const data = XLSX.utils.sheet_to_json(sheet, { defval: '' });
                        callback(data);
                    } catch (err) { showAlert('Error reading Excel: ' + err.message, 'error'); }
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function handleDataFile(file) {
            if (!file) return;
            
            parseFile(file, function(data) {
                if (data.length === 0) {
                    document.getElementById('dataFileStatus').innerHTML = 'Error: Empty file';
                    document.getElementById('dataFileStatus').className = 'file-status error';
                    return;
                }
                
                // PRE-PROCESS: Convert to numeric where possible
                originalData = preprocessData(data);
                originalColumns = Object.keys(data[0]);
                dataFile = file;
                
                // Count how many values were converted
                let numericCount = 0;
                let naCount = 0;
                originalData.forEach(row => {
                    Object.values(row).forEach(val => {
                        if (val === null) naCount++;
                        else if (typeof val === 'number') numericCount++;
                    });
                });
                
                document.getElementById('dataFileStatus').innerHTML = 
                    'Loaded: ' + file.name + '<br>' + 
                    data.length + ' rows, ' + originalColumns.length + ' columns<br>' +
                    '<small style="color:#666;">Numeric values: ' + numericCount.toLocaleString() + ' | NA values: ' + naCount.toLocaleString() + '</small>';
                document.getElementById('dataFileStatus').className = 'file-status loaded';
                
                showAlert('Data file loaded and preprocessed! NA values standardized.', 'success');
                checkBothFilesLoaded();
            });
        }

        function handleConfigFile(file) {
            if (!file) return;
            
            parseFile(file, function(data) {
                if (data.length === 0) {
                    document.getElementById('configFileStatus').innerHTML = 'Error: Empty file';
                    document.getElementById('configFileStatus').className = 'file-status error';
                    return;
                }
                
                // Parse computation rules
                computations = [];
                const cols = Object.keys(data[0]);
                
                // Find the right columns (flexible naming)
                let varCol = cols.find(c => c.toLowerCase().includes('new') || c.toLowerCase().includes('variable') || c.toLowerCase().includes('name')) || cols[0];
                let opCol = cols.find(c => c.toLowerCase().includes('operation') || c.toLowerCase().includes('op')) || cols[1];
                let compCol = cols.find(c => c.toLowerCase().includes('component') || c.toLowerCase().includes('columns') || c.toLowerCase().includes('vars')) || cols[2];
                
                data.forEach(function(row, index) {
                    const newVar = String(row[varCol] || '').trim();
                    const operation = normalizeOperation(String(row[opCol] || ''));
                    const components = String(row[compCol] || '').split(',').map(c => c.trim()).filter(c => c);
                    
                    if (newVar && operation && components.length > 0) {
                        computations.push({
                            id: 'config-' + index,
                            newVariable: newVar,
                            operation: operation,
                            components: components,
                            source: 'config'
                        });
                    }
                });
                
                configFile = file;
                
                document.getElementById('configFileStatus').innerHTML = 'Loaded: ' + file.name + '<br>' + computations.length + ' rules found';
                document.getElementById('configFileStatus').className = 'file-status loaded';
                
                showAlert('Config file loaded! ' + computations.length + ' computation rules found.', 'success');
                checkBothFilesLoaded();
            });
        }

        function checkBothFilesLoaded() {
            if (dataFile && configFile && originalData.length > 0) {
                buildConfigInterface();
            }
        }

        function buildConfigInterface() {
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('configSection').classList.remove('hidden');
            
            // Validate computations SEQUENTIALLY - each computed variable becomes available for next
            let validCount = 0;
            let invalidCount = 0;
            let availableColumns = [...originalColumns]; // Start with original columns
            
            computations.forEach(function(comp) {
                // Resolve component names (case-insensitive matching)
                comp.resolvedComponents = [];
                comp.missingCols = [];
                
                comp.components.forEach(function(compName) {
                    const resolved = findMatchingColumn(compName, availableColumns);
                    if (resolved) {
                        comp.resolvedComponents.push(resolved);
                    } else {
                        comp.missingCols.push(compName);
                    }
                });
                
                comp.isValid = comp.missingCols.length === 0 && comp.resolvedComponents.length > 0;
                
                if (comp.isValid) {
                    validCount++;
                    // Add this computed variable to available columns for subsequent computations
                    availableColumns.push(normalizeColName(comp.newVariable));
                    comp.isComputed = true;
                } else {
                    invalidCount++;
                    comp.isComputed = false;
                }
            });
            
            // Stats
            document.getElementById('configStats').innerHTML = 
                '<div class="stats-card"><h4>Data Columns</h4><div class="metric-value">' + originalColumns.length + '</div><p>Original</p></div>' +
                '<div class="stats-card"><h4>Computation Rules</h4><div class="metric-value">' + computations.length + '</div><p>Total</p></div>' +
                '<div class="stats-card"><h4>Valid</h4><div class="metric-value success">' + validCount + '</div><p>Ready to compute</p></div>' +
                '<div class="stats-card"><h4>Invalid</h4><div class="metric-value ' + (invalidCount > 0 ? 'danger' : '') + '">' + invalidCount + '</div><p>Missing columns</p></div>';
            
            // Column tags - show original columns
            const tagsContainer = document.getElementById('columnTags');
            tagsContainer.innerHTML = '';
            originalColumns.forEach(function(col) {
                const tag = document.createElement('span');
                tag.className = 'column-tag';
                tag.textContent = col;
                tagsContainer.appendChild(tag);
            });
            
            renderComputeList();
        }

        function renderComputeList() {
            const list = document.getElementById('computeList');
            list.innerHTML = '';
            
            if (computations.length === 0) {
                list.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">No computation rules found in config file.</div>';
                return;
            }
            
            // Track which variables have been computed (for showing dependencies)
            let computedSoFar = [];
            
            computations.forEach(function(comp, index) {
                const item = document.createElement('div');
                item.className = 'compute-item ' + (comp.isValid ? 'valid' : 'invalid');
                item.id = 'comp-' + comp.id;
                
                // Format components with found/missing/computed indicators
                // Show resolved names if different from original
                let componentsHtml = comp.components.map(function(c, i) {
                    const resolved = comp.resolvedComponents ? comp.resolvedComponents[i] : null;
                    
                    if (resolved) {
                        // Check if it's an original column or computed column
                        if (originalColumns.includes(resolved)) {
                            const displayName = (resolved !== c) ? c + ' → ' + resolved : resolved;
                            return '<span class="found">' + displayName + '</span>';
                        } else if (computedSoFar.includes(resolved)) {
                            return '<span class="computed">' + resolved + ' ⟵</span>';
                        } else {
                            return '<span class="found">' + resolved + '</span>';
                        }
                    } else {
                        return '<span class="missing">' + c + ' ✗</span>';
                    }
                }).join(', ');
                
                // Get display name for operation
                const displayOp = operationDisplayNames[comp.operation] || comp.operation;
                
                // Add order number to show sequence
                const orderBadge = '<span style="background:#004080;color:white;padding:2px 8px;border-radius:10px;font-size:10px;margin-right:8px;">#' + (index + 1) + '</span>';
                
                item.innerHTML = 
                    '<div class="var-name new">' + orderBadge + comp.newVariable + '</div>' +
                    '<div class="operation-badge ' + comp.operation + '">' + displayOp + '</div>' +
                    '<div class="components-list">' + componentsHtml + '</div>' +
                    '<div class="status-badge ' + (comp.isValid ? 'valid' : 'invalid') + '">' + (comp.isValid ? 'Valid' : 'Missing: ' + comp.missingCols.join(', ')) + '</div>';
                
                list.appendChild(item);
                
                // Add to computed list if valid
                if (comp.isValid) {
                    computedSoFar.push(normalizeColName(comp.newVariable));
                }
            });
        }

        /**
         * SMART COLUMN ORDERING
         * Places new computed column right after the LAST component column it depends on
         * Example: allout_u5, allout_ov5 are at positions 5,6 -> allout goes to position 7
         */
        function buildOrderedColumns(validComps) {
            // Start with original columns
            let result = [...originalColumns];
            
            validComps.forEach(function(comp) {
                // Find the position of the LAST component column in current result
                // Use resolvedComponents (the actual column names used)
                let lastComponentPos = -1;
                (comp.resolvedComponents || comp.components).forEach(function(compCol) {
                    const pos = result.indexOf(compCol);
                    if (pos > lastComponentPos) {
                        lastComponentPos = pos;
                    }
                });
                
                // Insert new column right after the last component
                if (lastComponentPos >= 0) {
                    result.splice(lastComponentPos + 1, 0, comp.newVariable);
                } else {
                    // Fallback: add at end
                    result.push(comp.newVariable);
                }
            });
            
            return result;
        }

        function computeVariables() {
            const validComps = computations.filter(c => c.isValid);
            
            if (validComps.length === 0) {
                showAlert('No valid computations to perform', 'error');
                return;
            }
            
            // Create copy of data
            computedData = originalData.map(row => ({...row}));
            newColumns = [];
            const results = [];
            
            // Track all available columns (original + computed so far)
            let allAvailableColumns = [...originalColumns];
            
            // Process computations SEQUENTIALLY - order matters for dependencies
            validComps.forEach(function(comp) {
                try {
                    let successCount = 0;
                    let nullCount = 0;
                    let sampleCalc = null;
                    
                    // Process each row
                    computedData.forEach(function(row, rowIndex) {
                        // Get values for all components
                        const values = [];
                        const rawValues = [];
                        
                        comp.resolvedComponents.forEach(function(colName) {
                            const rawVal = row[colName];
                            rawValues.push(rawVal);
                            
                            // Convert to number, treating NA as 0 for most operations
                            if (rawVal === null || rawVal === undefined) {
                                values.push({ num: 0, isNA: true });
                            } else if (typeof rawVal === 'number') {
                                values.push({ num: rawVal, isNA: false });
                            } else {
                                const parsed = toNumeric(rawVal);
                                values.push({ num: parsed.isNA ? 0 : parsed.value, isNA: parsed.isNA });
                            }
                        });
                        
                        let result = null;
                        
                        switch(comp.operation) {
                            case 'addition':
                                // NA + 2 = 2 (NA treated as 0)
                                result = 0;
                                values.forEach(v => {
                                    result += v.num;
                                });
                                break;
                                
                            case 'subtraction':
                                // 2 - NA = 2 (NA treated as 0)
                                if (values.length >= 2) {
                                    result = Math.max(0, values[0].num - values[1].num);
                                } else if (values.length === 1) {
                                    result = values[0].num;
                                }
                                break;
                                
                            case 'multiplication':
                                // If any value is NA, treat as 0, so result = 0
                                result = 1;
                                let hasNA = false;
                                values.forEach(v => {
                                    if (v.isNA) hasNA = true;
                                    result *= v.num;
                                });
                                // If any was NA (which becomes 0), result is already 0
                                break;
                                
                            case 'division':
                                // Can't divide by 0 or NA
                                if (values.length >= 2) {
                                    const numerator = values[0].num;
                                    const denominator = values[1].num;
                                    if (!values[1].isNA && denominator !== 0) {
                                        result = numerator / denominator;
                                    }
                                }
                                break;
                                
                            case 'average':
                                // Average of non-NA values only
                                const validVals = values.filter(v => !v.isNA);
                                if (validVals.length > 0) {
                                    const sum = validVals.reduce((a, b) => a + b.num, 0);
                                    result = sum / validVals.length;
                                }
                                break;
                                
                            case 'maximum':
                                const maxVals = values.filter(v => !v.isNA).map(v => v.num);
                                if (maxVals.length > 0) {
                                    result = Math.max(...maxVals);
                                }
                                break;
                                
                            case 'minimum':
                                const minVals = values.filter(v => !v.isNA).map(v => v.num);
                                if (minVals.length > 0) {
                                    result = Math.min(...minVals);
                                }
                                break;
                        }
                        
                        // Store result
                        row[comp.newVariable] = result;
                        
                        // Track stats
                        if (result !== null) {
                            successCount++;
                            // Capture first non-trivial calculation for debugging
                            if (sampleCalc === null && result !== 0) {
                                sampleCalc = {
                                    row: rowIndex + 1,
                                    inputs: comp.resolvedComponents.map((c, i) => c + '=' + rawValues[i]),
                                    result: result
                                };
                            }
                        } else {
                            nullCount++;
                        }
                    });
                    
                    // Add to available columns for next computation
                    allAvailableColumns.push(comp.newVariable);
                    newColumns.push(comp.newVariable);
                    
                    results.push({
                        variable: comp.newVariable,
                        operation: comp.operation,
                        components: comp.components.join(', '),
                        resolvedComponents: comp.resolvedComponents.join(', '),
                        status: 'success',
                        successCount: successCount,
                        nullCount: nullCount,
                        sampleCalc: sampleCalc
                    });
                    
                } catch (err) {
                    console.error('Computation error:', err);
                    results.push({
                        variable: comp.newVariable,
                        operation: comp.operation,
                        components: comp.components.join(', '),
                        status: 'error',
                        error: err.message
                    });
                }
            });
            
            // Build smart column ordering
            orderedColumns = buildOrderedColumns(validComps);
            
            showResults(results);
        }

        function showResults(results) {
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');
            
            const successCount = results.filter(r => r.status === 'success').length;
            const errorCount = results.filter(r => r.status === 'error').length;
            
            document.getElementById('resultStats').innerHTML = 
                '<div class="stats-card"><h4>Original Columns</h4><div class="metric-value">' + originalColumns.length + '</div><p>From data file</p></div>' +
                '<div class="stats-card"><h4>New Columns</h4><div class="metric-value success">' + newColumns.length + '</div><p>Computed</p></div>' +
                '<div class="stats-card"><h4>Total Columns</h4><div class="metric-value">' + orderedColumns.length + '</div><p>In result</p></div>' +
                '<div class="stats-card"><h4>Total Rows</h4><div class="metric-value">' + computedData.length + '</div><p>Processed</p></div>';
            
            // Summary with debug info
            const summary = document.getElementById('computeSummary');
            let html = '';
            results.forEach(function(r) {
                const displayOp = operationDisplayNames[r.operation] || r.operation;
                if (r.status === 'success') {
                    let sampleInfo = '';
                    if (r.sampleCalc) {
                        sampleInfo = '<br><small style="color:#666;">Sample (row ' + r.sampleCalc.row + '): ' + 
                            r.sampleCalc.inputs.join(' + ') + ' = <strong>' + 
                            (typeof r.sampleCalc.result === 'number' ? r.sampleCalc.result.toFixed(2) : r.sampleCalc.result) + 
                            '</strong></small>';
                    }
                    html += '<div class="alert alert-success" style="margin: 0.5rem 0;">' +
                        '<strong>' + r.variable + '</strong> = ' + displayOp.toUpperCase() + '(' + r.resolvedComponents + ')' +
                        '<br><small style="color:#155724;">✓ ' + r.successCount + ' values computed, ' + r.nullCount + ' null results</small>' +
                        sampleInfo +
                        '</div>';
                } else {
                    html += '<div class="alert alert-error" style="margin: 0.5rem 0;"><strong>' + r.variable + '</strong> - Error: ' + r.error + '</div>';
                }
            });
            summary.innerHTML = html;
            
            // Preview table with ORDERED columns
            const thead = document.getElementById('previewHead');
            const tbody = document.getElementById('previewBody');
            thead.innerHTML = '';
            tbody.innerHTML = '';
            
            let headerRow = '<tr>';
            orderedColumns.forEach(function(col) { 
                const isNew = newColumns.includes(col);
                headerRow += '<th' + (isNew ? ' class="new-col"' : '') + '>' + col + (isNew ? ' ★' : '') + '</th>'; 
            });
            thead.innerHTML = headerRow + '</tr>';
            
            computedData.slice(0, 100).forEach(function(row) {
                let tr = '<tr>';
                orderedColumns.forEach(function(col) {
                    const val = row[col];
                    const isNew = newColumns.includes(col);
                    let displayVal = val;
                    
                    if (val === null || val === undefined) {
                        displayVal = '';
                    } else if (typeof val === 'number') {
                        displayVal = Number.isInteger(val) ? val : val.toFixed(2);
                    }
                    tr += '<td' + (isNew ? ' class="new-col"' : '') + '>' + displayVal + '</td>';
                });
                tbody.innerHTML += tr + '</tr>';
            });
            
            showAlert(successCount + ' new variables computed successfully! Columns ordered by dependencies.', 'success');
        }

        function downloadCSV() {
            // Reorder data columns before export
            const orderedData = computedData.map(function(row) {
                const newRow = {};
                orderedColumns.forEach(function(col) {
                    newRow[col] = row[col];
                });
                return newRow;
            });
            
            const csv = Papa.unparse(orderedData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'computed_data.csv';
            a.click();
            URL.revokeObjectURL(url);
            showAlert('CSV downloaded with ordered columns!', 'success');
        }

        function downloadExcel() {
            // Reorder data columns before export
            const orderedData = computedData.map(function(row) {
                const newRow = {};
                orderedColumns.forEach(function(col) {
                    newRow[col] = row[col];
                });
                return newRow;
            });
            
            const ws = XLSX.utils.json_to_sheet(orderedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Computed Data');
            XLSX.writeFile(wb, 'computed_data.xlsx');
            showAlert('Excel downloaded with ordered columns!', 'success');
        }

        function backToConfig() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('configSection').classList.remove('hidden');
        }

        function downloadTemplate() {
            const templateData = [
                { new_variable: 'total_cases', operation: 'addition', components: 'confirmed_cases, suspected_cases' },
                { new_variable: 'net_cases', operation: 'subtraction', components: 'total_cases, deaths' },
                { new_variable: 'case_rate', operation: 'division', components: 'cases, population' },
                { new_variable: 'avg_monthly', operation: 'average', components: 'jan, feb, mar, apr, may, jun' },
                { new_variable: 'max_value', operation: 'maximum', components: 'value1, value2, value3' },
                { new_variable: 'min_value', operation: 'minimum', components: 'value1, value2, value3' },
                { new_variable: 'total_cost', operation: 'multiplication', components: 'quantity, unit_price' }
            ];
            
            const csv = Papa.unparse(templateData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'compute_variables_template.csv';
            a.click();
            URL.revokeObjectURL(url);
            showAlert('Template downloaded! Edit with your computation rules.', 'success');
        }

        function resetAll() {
            dataFile = null;
            configFile = null;
            originalData = [];
            originalColumns = [];
            originalColumnsLower = {};
            computations = [];
            computedData = [];
            newColumns = [];
            orderedColumns = [];
            
            document.getElementById('dataFileInput').value = '';
            document.getElementById('configFileInput').value = '';
            document.getElementById('dataFileStatus').innerHTML = '';
            document.getElementById('dataFileStatus').className = 'file-status';
            document.getElementById('configFileStatus').innerHTML = '';
            document.getElementById('configFileStatus').className = 'file-status';
            document.getElementById('alertContainer').innerHTML = '';
            
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
        }
    </script>
</body>
</html>
